#!/usr/bin/env python3
"""
AI Backend Lite Dashboard

A lightweight, information-dense TUI for monitoring AI backend providers.
"""

import asyncio
import subprocess
import time
from dataclasses import dataclass
from typing import Dict, List

import psutil
import requests
from textual import work
from textual.app import App, ComposeResult
from textual.binding import Binding
from textual.containers import Container, Horizontal, Vertical
from textual.reactive import reactive
from textual.widgets import (
    Button,
    Footer,
    Header,
    Label,
    Static,
)


@dataclass
class ProviderStatus:
    """Represents the status of a provider."""
    name: str
    status: str  # 'active', 'inactive', 'error'
    port: int
    model_count: int
    response_time: float
    uptime: str = "N/A"


class ProviderMonitor:
    """Handles monitoring of AI backend providers."""

    PROVIDER_ENDPOINTS = {
        "ollama": "http://127.0.0.1:11434/api/tags",
        "llama_cpp_python": "http://127.0.0.1:8000/v1/models",
        "llama_cpp_native": "http://127.0.0.1:8080/v1/models",
        "vllm-qwen": "http://127.0.0.1:8001/v1/models",
        "vllm-dolphin": "http://127.0.0.1:8002/v1/models",
    }

    def check_provider_health(self, name: str, endpoint: str) -> ProviderStatus:
        """Check the health of a provider."""
        start_time = time.time()

        try:
            response = requests.get(endpoint, timeout=3)  # Shorter timeout
            response_time = time.time() - start_time

            if response.status_code == 200:
                try:
                    data = response.json()
                    if "data" in data and isinstance(data["data"], list):
                        model_count = len(data["data"])
                    else:
                        model_count = 0
                except (ValueError, TypeError, KeyError):
                    model_count = 0

                port = int(endpoint.split(":")[2].split("/")[0])

                return ProviderStatus(
                    name=name,
                    status="active",
                    port=port,
                    model_count=model_count,
                    response_time=round(response_time * 1000, 1)
                )
            else:
                return ProviderStatus(
                    name=name,
                    status="error",
                    port=int(endpoint.split(":")[2].split("/")[0]),
                    model_count=0,
                    response_time=0.0
                )
        except requests.exceptions.Timeout:
            return ProviderStatus(
                name=name,
                status="inactive",
                port=int(endpoint.split(":")[2].split("/")[0]),
                model_count=0,
                response_time=3000.0  # Mark timeout
            )
        except requests.exceptions.ConnectionError:
            return ProviderStatus(
                name=name,
                status="inactive",
                port=int(endpoint.split(":")[2].split("/")[0]),
                model_count=0,
                response_time=0.0
            )
        except Exception:
            return ProviderStatus(
                name=name,
                status="error",
                port=int(endpoint.split(":")[2].split("/")[0]),
                model_count=0,
                response_time=0.0
            )

    def get_all_provider_status(self) -> List[ProviderStatus]:
        """Get status for all providers."""
        return [
            self.check_provider_health(name, endpoint)
            for name, endpoint in self.PROVIDER_ENDPOINTS.items()
        ]

    def systemctl_command(self, command: str, service_name: str) -> bool:
        """Execute a systemctl command."""
        try:
            result = subprocess.run(
                ["systemctl", "--user", command, service_name],
                capture_output=True,
                text=True,
                check=False,
                timeout=5  # Shorter timeout
            )
            return result.returncode == 0
        except subprocess.TimeoutExpired:
            return False
        except Exception:
            return False


class StatusLabel(Static):
    """A label that changes color based on status."""

    def set_status(self, status: str, text: str):
        self.update(text)
        # Clear all status classes
        for cls in ["active", "inactive", "error"]:
            self.remove_class(cls)
        # Add the appropriate class
        self.add_class(status)
        # Set the status text
        self.status = status


class ProviderStatusWidget(Vertical):
    """Widget showing status for a single provider."""

    def __init__(self, provider_name: str):
        super().__init__()
        self.provider_name = provider_name
        self.provider_monitor = ProviderMonitor()

    def compose(self) -> ComposeResult:
        with Horizontal(classes="provider-row"):
            yield Label(self.provider_name, classes="provider-name")
            yield StatusLabel("● Initializing...", classes="status-label initializing", id=f"status_{self.provider_name}")
            yield Label("-", classes="port-label", id=f"port_{self.provider_name}")
            yield Label("-", classes="models-label", id=f"models_{self.provider_name}")
            yield Label("-", classes="response-label", id=f"response_{self.provider_name}")
            yield Horizontal(id=f"controls_{self.provider_name}", classes="controls")

    def update_status(self, status: ProviderStatus):
        """Update the provider status display."""
        # Update status label with color coding
        status_widget = self.query_one(f"#status_{self.provider_name}", StatusLabel)
        status_text = f"● {status.status.title()}"
        status_widget.set_status(status.status, status_text)

        # Update other fields
        port_widget = self.query_one(f"#port_{self.provider_name}", Label)
        port_widget.update(f"{status.port}")

        models_widget = self.query_one(f"#models_{self.provider_name}", Label)
        models_widget.update(f"{status.model_count}")

        response_widget = self.query_one(f"#response_{self.provider_name}", Label)
        response_widget.update(f"{status.response_time}ms" if status.response_time > 0 else "-")


class QuickActions(Static):
    """Quick action buttons."""

    def compose(self) -> ComposeResult:
        with Horizontal(classes="quick-actions"):
            yield Button("Refresh All", id="refresh_all", variant="primary")
            yield Button("Restart LiteLLM", id="restart_litellm", variant="warning")


class SystemMetrics(Static):
    """Display system metrics."""

    cpu_percent = reactive(0.0)
    memory_percent = reactive(0.0)

    def on_mount(self) -> None:
        self.set_interval(2.0, self.update_metrics)

    def update_metrics(self):
        """Update system metrics."""
        self.cpu_percent = psutil.cpu_percent(interval=None)  # Non-blocking
        self.memory_percent = psutil.virtual_memory().percent

    def watch_cpu_percent(self, cpu: float):
        """Update when CPU changes."""
        try:
            cpu_widget = self.query_one("#cpu_label", Label)
            cpu_widget.update(f"CPU: {cpu:.1f}%")

            # Add color coding based on usage
            if cpu > 80:
                cpu_widget.add_class("high")
                cpu_widget.remove_class("medium")
                cpu_widget.remove_class("low")
            elif cpu > 50:
                cpu_widget.add_class("medium")
                cpu_widget.remove_class("high")
                cpu_widget.remove_class("low")
            else:
                cpu_widget.add_class("low")
                cpu_widget.remove_class("high")
                cpu_widget.remove_class("medium")
        except:
            pass

    def watch_memory_percent(self, memory: float):
        """Update when memory changes."""
        try:
            mem_widget = self.query_one("#memory_label", Label)
            mem_widget.update(f"MEM: {memory:.1f}%")

            # Add color coding based on usage
            if memory > 80:
                mem_widget.add_class("high")
                mem_widget.remove_class("medium")
                mem_widget.remove_class("low")
            elif memory > 50:
                mem_widget.add_class("medium")
                mem_widget.remove_class("high")
                mem_widget.remove_class("low")
            else:
                mem_widget.add_class("low")
                mem_widget.remove_class("high")
                mem_widget.remove_class("medium")
        except:
            pass

    def compose(self) -> ComposeResult:
        with Horizontal(classes="system-metrics"):
            yield Label("CPU: 0.0%", id="cpu_label", classes="metric low")
            yield Label("MEM: 0.0%", id="memory_label", classes="metric low")


class AIBackendDashboard(App):
    """Lightweight AI Backend Dashboard."""

    CSS = """
    Screen {
        layout: vertical;
    }

    Header {
        height: 1;
        dock: top;
        background: $primary;
        color: $text;
        text-style: bold;
    }

    Footer {
        height: 1;
        dock: bottom;
        background: $primary;
        color: $text;
    }

    .container {
        layout: grid;
        grid-size: 2;
        grid-columns: 1fr 1fr;
        height: 1fr;
    }

    .providers-panel {
        height: 1fr;
        width: 1fr;
        border: solid $primary;
        padding: 0 1;
    }

    .metrics-panel {
        height: 1fr;
        width: 1fr;
        border: solid $secondary;
        padding: 0 1;
    }

    .provider-row {
        height: auto;
        margin: 0 0 1 0;
        align: center middle;
    }

    .provider-name {
        width: 18;
        text-style: bold;
        background: $boost;
        text-align: center;
    }

    .status-label {
        width: 15;
        text-align: center;
    }

    .status-label.active {
        color: $success;
    }

    .status-label.inactive {
        color: $warning;
    }

    .status-label.error {
        color: $error;
    }

    .port-label, .models-label, .response-label {
        width: 8;
        text-align: center;
        background: $boost;
    }

    .controls {
        width: 20;
        height: 1;
    }

    .quick-actions {
        margin: 1 0;
        height: auto;
    }

    .system-metrics {
        margin: 0 0 1 0;
        height: auto;
    }

    .metric {
        width: 12;
        text-align: center;
        background: $boost;
        border: solid $primary;
    }

    .metric.low {
        color: $success;
    }

    .metric.medium {
        color: $warning;
    }

    .metric.high {
        color: $error;
    }

    Button {
        width: 15;
        height: 1;
        margin: 0 1;
    }
    """

    BINDINGS = [
        Binding("r", "refresh", "Refresh"),
        Binding("q", "quit", "Quit"),
        Binding("ctrl+d", "toggle_dark", "Toggle Dark Mode"),
        Binding("f1", "show_help", "Help"),
    ]

    def __init__(self):
        super().__init__()
        self.provider_monitor = ProviderMonitor()

    def compose(self) -> ComposeResult:
        """Create the dashboard UI."""
        yield Header("AI Backend Lite Dashboard")

        with Container(classes="container"):
            with Vertical(classes="providers-panel"):
                yield Label("[b]Providers Status", classes="panel-title")
                yield ProviderStatusWidget("ollama")
                yield ProviderStatusWidget("vllm-qwen")
                yield ProviderStatusWidget("vllm-dolphin")
                yield ProviderStatusWidget("llama_cpp_python")
                yield ProviderStatusWidget("llama_cpp_native")

            with Vertical(classes="metrics-panel"):
                yield Label("[b]System Metrics", classes="panel-title")
                yield SystemMetrics()
                yield QuickActions()

        yield Footer()

    def on_mount(self) -> None:
        """Start auto-refresh when app mounts."""
        self.refresh_data()
        self.set_interval(5.0, self.refresh_data)

    def refresh_data(self):
        """Refresh all provider data."""
        # Run in background to prevent UI blocking
        self.refresh_providers()

    @work(thread=True)
    async def refresh_providers(self):
        """Refresh provider data in background."""
        statuses = self.provider_monitor.get_all_provider_status()

        for status in statuses:
            # Schedule UI update on main thread
            self.call_from_thread(self.update_provider_status, status.name, status)

    def on_button_pressed(self, event: Button.Pressed) -> None:
        """Handle button presses."""
        if event.button.id == "refresh_all":
            self.refresh_data()
            self.notify("Dashboard refreshed!")
        elif event.button.id == "restart_litellm":
            self.action_restart_service("litellm.service", "LiteLLM")

    def action_show_help(self) -> None:
        """Show help information."""
        self.notify("AI Backend Lite Dashboard\n\n"
                   "R - Refresh all data\n"
                   "Q - Quit application\n"
                   "Ctrl+D - Toggle dark mode\n"
                   "F1 - Show this help\n\n"
                   "This dashboard monitors AI backend providers and system resources.")

    def update_provider_status(self, provider_name: str, status: ProviderStatus):
        """Update status for a specific provider."""
        try:
            for child in self.query(ProviderStatusWidget).results():
                if child.provider_name == provider_name:
                    child.update_status(status)
                    break
        except:
            pass

    @work(thread=True)  # Run in background thread
    async def action_restart_service(self, service_name: str, display_name: str):
        """Restart a service in the background."""
        self.notify(f"Restarting {display_name}...")
        success = self.provider_monitor.systemctl_command("restart", service_name)
        if success:
            self.notify(f"{display_name} restarted successfully!")
        else:
            self.notify(f"Failed to restart {display_name}!", severity="error")

        # Refresh data after action
    def action_show_help(self) -> None:
        """Show help information."""
        self.notify("AI Backend Lite Dashboard\n\n"
                   "R - Refresh all data\n"
                   "Q - Quit application\n"
                   "Ctrl+D - Toggle dark mode\n"
                   "F1 - Show this help\n\n"
                   "This dashboard monitors AI backend providers and system resources.")


if __name__ == "__main__":
    app = AIBackendDashboard()
    app.run()
