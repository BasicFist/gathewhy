#!/usr/bin/env python3
"""
AI Backend Provider Command Center

A terminal-based dashboard for monitoring and managing AI backend providers.
"""

import subprocess
import time
from dataclasses import dataclass
from typing import Dict, List

import psutil
import requests
from rich.console import RenderableType
from rich.table import Table
from textual import on
from textual.app import App, ComposeResult
from textual.binding import Binding
from textual.containers import Horizontal, Vertical, VerticalScroll
from textual.reactive import reactive
from textual.widgets import (
    Button,
    Footer,
    Header,
    Static,
    DataTable,
    Sparkline,
)


@dataclass
class ProviderStatus:
    """Represents the status of a provider."""
    name: str
    status: str  # 'active', 'inactive', 'error', 'loading'
    port: int
    endpoint: str
    model_count: int
    response_time: float
    memory_usage: float
    cpu_usage: float
    active_requests: int


class ProviderMonitor:
    """Handles monitoring of AI backend providers."""

    PROVIDER_ENDPOINTS = {
        "ollama": "http://127.0.0.1:11434/api/tags",
        "llama_cpp_python": "http://127.0.0.1:8000/v1/models",
        "llama_cpp_native": "http://127.0.0.1:8080/v1/models",
        "vllm-qwen": "http://127.0.0.1:8001/v1/models",
        "vllm-dolphin": "http://127.0.0.1:8002/v1/models",
    }

    def get_system_metrics(self) -> Dict[str, float]:
        """Get system-level metrics."""
        return {
            "cpu_percent": psutil.cpu_percent(interval=1),
            "memory_percent": psutil.virtual_memory().percent,
            "disk_percent": psutil.disk_usage('/').percent,
        }

    def check_provider_health(self, name: str, endpoint: str) -> ProviderStatus:
        """Check the health of a provider."""
        start_time = time.time()

        try:
            response = requests.get(endpoint, timeout=5)
            response_time = time.time() - start_time

            if response.status_code == 200:
                # Try to get model count from response
                try:
                    data = response.json()
                    if "data" in data and isinstance(data["data"], list):
                        model_count = len(data["data"])
                    else:
                        model_count = 0
                except (ValueError, TypeError, KeyError):  # JSON decode errors or key errors
                    model_count = 0

                # Extract port from endpoint
                port = int(endpoint.split(":")[2].split("/")[0])

                return ProviderStatus(
                    name=name,
                    status="active",
                    port=port,
                    endpoint=endpoint,
                    model_count=model_count,
                    response_time=round(response_time * 1000, 2),  # ms
                    memory_usage=0.0,  # Placeholder - would need actual implementation
                    cpu_usage=0.0,      # Placeholder - would need actual implementation
                    active_requests=0   # Placeholder - would need actual implementation
                )
            else:
                return ProviderStatus(
                    name=name,
                    status="error",
                    port=int(endpoint.split(":")[2].split("/")[0]),
                    endpoint=endpoint,
                    model_count=0,
                    response_time=0.0,
                    memory_usage=0.0,
                    cpu_usage=0.0,
                    active_requests=0
                )
        except requests.exceptions.Timeout:
            return ProviderStatus(
                name=name,
                status="inactive",  # Timeout usually means service is not responsive
                port=int(endpoint.split(":")[2].split("/")[0]),
                endpoint=endpoint,
                model_count=0,
                response_time=5000.0,  # Mark timeout explicitly
                memory_usage=0.0,
                cpu_usage=0.0,
                active_requests=0
            )
        except requests.exceptions.ConnectionError:
            return ProviderStatus(
                name=name,
                status="inactive",  # Connection error means service is not accessible
                port=int(endpoint.split(":")[2].split("/")[0]),
                endpoint=endpoint,
                model_count=0,
                response_time=0.0,
                memory_usage=0.0,
                cpu_usage=0.0,
                active_requests=0
            )
        except requests.exceptions.RequestException:
            return ProviderStatus(
                name=name,
                status="error",
                port=int(endpoint.split(":")[2].split("/")[0]),
                endpoint=endpoint,
                model_count=0,
                response_time=0.0,
                memory_usage=0.0,
                cpu_usage=0.0,
                active_requests=0
            )
        except ValueError:  # For int() conversion errors
            return ProviderStatus(
                name=name,
                status="error",
                port=0,  # Could not parse port
                endpoint=endpoint,
                model_count=0,
                response_time=0.0,
                memory_usage=0.0,
                cpu_usage=0.0,
                active_requests=0
            )

    def get_all_provider_status(self) -> List[ProviderStatus]:
        """Get status for all providers."""
        return [
            self.check_provider_health(name, endpoint)
            for name, endpoint in self.PROVIDER_ENDPOINTS.items()
        ]

    def check_systemd_service(self, service_name: str) -> bool:
        """Check if a systemd service is running."""
        try:
            result = subprocess.run(
                ["systemctl", "--user", "is-active", service_name],
                capture_output=True,
                text=True,
                check=False
            )
            return result.stdout.strip() == "active"
        except Exception:
            return False

    def systemctl_command(self, command: str, service_name: str) -> bool:
        """Execute a systemctl command."""
        try:
            result = subprocess.run(
                ["systemctl", "--user", command, service_name],
                capture_output=True,
                text=True,
                check=False,
                timeout=10  # Add a timeout to prevent hanging
            )
            return result.returncode == 0
        except subprocess.TimeoutExpired:
            # Log timeout error or handle it appropriately
            return False
        except Exception:
            return False


class ProviderStatusTable(Static):
    """Table showing provider status."""

    def __init__(self) -> None:
        super().__init__()
        self.provider_monitor = ProviderMonitor()

    def compose(self) -> ComposeResult:
        table = DataTable(id="provider_table", zebra_stripes=True)
        table.add_columns(
            "Provider",
            "Status",
            "Port",
            "Models",
            "Response (ms)",
            "Actions"
        )
        yield table

    def on_mount(self) -> None:
        """Refresh data when widget is mounted."""
        self.refresh_data()

    def refresh_data(self) -> None:
        """Refresh the provider status table."""
        try:
            table = self.query_one(DataTable)
            table.clear()

            statuses = self.provider_monitor.get_all_provider_status()
            for status in statuses:
                status_color = {
                    "active": "[green]● Active[/green]",
                    "inactive": "[red]● Inactive[/red]",
                    "error": "[red]● Error[/red]",
                    "loading": "[yellow]● Loading[/yellow]"
                }.get(status.status, status.status)

                # Just show the provider name in the actions column for now
                # (Interactive buttons aren't supported in DataTable cells)

                table.add_row(
                    status.name,
                    status_color,
                    str(status.port),
                    str(status.model_count),
                    str(status.response_time),
                    "See Controls Panel"  # Action buttons are in the control panel below
                )
        except Exception:
            # Table might not be ready yet or other error occurred
            pass


class SystemMetricsWidget(Static):
    """Widget showing system metrics."""

    def __init__(self) -> None:
        super().__init__()
        self.provider_monitor = ProviderMonitor()
        self.cpu_values = [0.0] * 20
        self.memory_values = [0.0] * 20
        self.refresh_data()

    def compose(self) -> ComposeResult:
        yield Horizontal(
            Vertical(
                Static("CPU Usage", classes="metric-title"),
                Sparkline(id="cpu_sparkline"),
                Static("0%", id="cpu_text", classes="metric-value"),
            ),
            Vertical(
                Static("Memory Usage", classes="metric-title"),
                Sparkline(id="memory_sparkline"),
                Static("0%", id="memory_text", classes="metric-value"),
            ),
            id="system_metrics"
        )

    def refresh_data(self) -> None:
        """Refresh the system metrics."""
        try:
            metrics = self.provider_monitor.get_system_metrics()

            # Update CPU values
            self.cpu_values = self.cpu_values[1:] + [metrics["cpu_percent"]]
            cpu_sparkline = self.query_one("#cpu_sparkline", Sparkline)
            cpu_sparkline.data = self.cpu_values
            cpu_text = self.query_one("#cpu_text", Static)
            cpu_text.update(f"{metrics['cpu_percent']:.1f}%")
        except Exception:
            pass  # Widget might not be ready yet or other error occurred

        # Update memory values
        try:
            metrics = self.provider_monitor.get_system_metrics()  # Get fresh metrics
            self.memory_values = self.memory_values[1:] + [metrics["memory_percent"]]
            mem_sparkline = self.query_one("#memory_sparkline", Sparkline)
            mem_sparkline.data = self.memory_values
            mem_text = self.query_one("#memory_text", Static)
            mem_text.update(f"{metrics['memory_percent']:.1f}%")
        except Exception:
            pass  # Widget might not be ready yet or other error occurred


class ProviderControlPanel(Static):
    """Panel for controlling individual providers."""

    def __init__(self) -> None:
        super().__init__()
        self.provider_monitor = ProviderMonitor()

    def compose(self) -> ComposeResult:
        with VerticalScroll(id="control_panel"):
            for provider in ["ollama", "vllm-qwen", "vllm-dolphin", "llama_cpp_python", "llama_cpp_native"]:
                with Horizontal(classes="provider-control"):
                    yield Static(f"[bold]{provider}[/bold]", classes="provider-name")
                    yield Button("Start", variant="success", id=f"start_{provider}")
                    yield Button("Stop", variant="error", id=f"stop_{provider}")
                    yield Button("Restart", variant="warning", id=f"restart_{provider}")
                    yield Static("Status: Checking...", id=f"status_{provider}")


class AIProviderDashboard(App):
    """AI Backend Provider Command Center."""

    BINDINGS = [
        Binding("r", "refresh", "Refresh"),
        Binding("q", "quit", "Quit"),
        Binding("t", "toggle_tabs", "Toggle Tabs"),
        Binding("c", "show_control", "Control Panel"),
        Binding("m", "show_metrics", "Metrics"),
        Binding("tab", "focus_next", "Next"),
        Binding("shift+tab", "focus_previous", "Previous"),
    ]

    CSS = """
    Screen {
        layout: vertical;
    }

    #main_container {
        layout: grid;
        grid-size: 2;
        grid-columns: 2fr 1fr;
        grid-rows: 1fr;
        height: 1fr;
    }

    #status_table {
        height: 1fr;
        width: 1fr;
        border: solid $primary;
        padding: 1;
    }

    #system_metrics {
        height: 1fr;
        border: solid $secondary;
        padding: 1;
    }

    #control_panel {
        height: 1fr;
        border: solid $accent;
        padding: 1;
    }

    .metric-title {
        text-style: bold;
        content-align: center middle;
    }

    .metric-value {
        text-style: bold;
        color: $success;
        content-align: center middle;
    }

    .provider-control {
        margin: 1 0;
        height: auto;
    }

    .provider-name {
        width: 20;
        margin-right: 1;
    }

    Button {
        width: 10;
        margin: 0 1;
    }
    """

    def __init__(self) -> None:
        super().__init__()
        self.provider_monitor = ProviderMonitor()

    def compose(self) -> ComposeResult:
        """Create child widgets for the app."""
        yield Header()

        with Horizontal(id="main_container"):
            # Left side: Status table
            with Vertical(id="status_table"):
                yield ProviderStatusTable()

            # Right side: System metrics and control panel
            with Vertical(id="system_metrics"):
                yield Static("System Metrics", classes="panel-title")
                yield SystemMetricsWidget()

                yield Static("Quick Actions", classes="panel-title")
                with Horizontal():
                    yield Button("Refresh All", id="refresh_all", variant="primary")
                    yield Button("Restart LiteLLM", id="restart_litellm", variant="warning")

        yield ProviderControlPanel()
        yield Footer()

    def on_mount(self) -> None:
        """Start the auto-refresh timer when the app mounts."""
        self.auto_refresh = True
        self.set_interval(5.0, self.refresh_all_data)

    def refresh_all_data(self) -> None:
        """Refresh all data in the dashboard."""
        if hasattr(self, 'auto_refresh') and self.auto_refresh:
            # Refresh the provider status table
            try:
                status_table = self.query_one(ProviderStatusTable)
                status_table.refresh_data()
            except Exception:
                pass  # Widget might not be mounted yet or other error occurred

            # Refresh system metrics
            try:
                metrics_widget = self.query_one(SystemMetricsWidget)
                metrics_widget.refresh_data()
            except Exception:
                pass  # Widget might not be mounted yet or other error occurred

    @on(Button.Pressed, "#refresh_all")
    def handle_refresh_all(self) -> None:
        """Handle refresh all button."""
        self.refresh_all_data()

    @on(Button.Pressed, "#restart_litellm")
    def handle_restart_litellm(self) -> None:
        """Handle restarting LiteLLM service."""
        self.notify("Restarting LiteLLM service...")
        success = self.provider_monitor.systemctl_command("restart", "litellm.service")
        if success:
            self.notify("LiteLLM service restarted successfully!")
        else:
            self.notify("Failed to restart LiteLLM service!", severity="error")

    @on(Button.Pressed)
    def handle_provider_control(self, event: Button.Pressed) -> None:
        """Handle provider control buttons."""
        button_id = event.button.id
        if button_id and ("start_" in button_id or "stop_" in button_id or "restart_" in button_id):
            parts = button_id.split("_")
            action = parts[0]  # start, stop, or restart
            provider = "_".join(parts[1:])  # the provider name

            # Map provider names to systemd service names
            service_map = {
                "ollama": "ollama.service",
                "vllm-qwen": "vllm.service",
                "vllm-dolphin": "vllm-dolphin.service",
                "llama_cpp_python": "llamacpp-python.service",
                "llama_cpp_native": "llama-cpp-native.service",  # This might not exist
            }

            service_name = service_map.get(provider)
            if not service_name:
                self.notify(f"Service for {provider} not mapped!", severity="error")
                return

            if action == "start":
                self.notify(f"Starting {provider}...")
                success = self.provider_monitor.systemctl_command("start", service_name)
                if success:
                    self.notify(f"{provider} started successfully!")
                else:
                    self.notify(f"Failed to start {provider}!", severity="error")
            elif action == "stop":
                self.notify(f"Stopping {provider}...")
                success = self.provider_monitor.systemctl_command("stop", service_name)
                if success:
                    self.notify(f"{provider} stopped successfully!")
                else:
                    self.notify(f"Failed to stop {provider}!", severity="error")
            elif action == "restart":
                self.notify(f"Restarting {provider}...")
                success = self.provider_monitor.systemctl_command("restart", service_name)
                if success:
                    self.notify(f"{provider} restarted successfully!")
                else:
                    self.notify(f"Failed to restart {provider}!", severity="error")

            # Refresh data after action
            self.refresh_all_data()

    def action_refresh(self) -> None:
        """Manual refresh action."""
        self.refresh_all_data()
        self.notify("Dashboard refreshed!")


def main():
    """Run the AI Provider Dashboard application."""
    app = AIProviderDashboard()
    app.run()


if __name__ == "__main__":
    main()
